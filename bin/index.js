#! /usr/bin/env node
const fs = require('fs')
const chalk = require('chalk')
const boxen = require('boxen')
const yargs = require('yargs');
const Table = require('cli-table3');
const figlet = require("figlet");
const { execSync } = require('child_process');

const usage = chalk.green(figlet.textSync("nvr"))
  + chalk.keyword('violet')(
    "\nUsage:"
    + "\n nvr \t Generate report with default settings"
    + "\n nvr -p <project> \t Generate report with <project> as header"
    + "\n nvr -d \t Generate report including dev dependencies"
    + "\n nvr -c \t Generate report in debugging mode showing the steps results in the console"
    + "\n"
    + boxen(
      chalk.green(
        "\n" + "Generate vulnerability report from a npm project\nbased on npm audit json reponse" + "\n"
      ),
      { padding: 1, borderColor: 'green', dimBorder: true },
    )
  + "\n"
);

const options = yargs
  .usage(usage)
  .option("p", {
    alias: "project",
    describe: "Name of the analised project used in the report",
    type: "string",
    demandOption: false,
  })
  .option("d", {
    alias: "dev",
    describe: "Include dev dependencies in the report",
    type: "boolean",
    demandOption: false,
  })
  .option("c", {
    alias: "console",
    describe: "Allow console log for debugging",
    type: "boolean",
    demandOption: false,
  })
  .help(true)
  .argv;

const shouldLog = options.console;
const includeDevDependencies = options.dev;
if (shouldLog) console.log('\n====== LOG ENABLE =====\n');
if (shouldLog) console.log(`\nInclude dev dependencies: ${includeDevDependencies}\n`);

let npmAuditJson;
try {
  npmAuditJson = JSON.parse(execSync(
    `npm audit --json ${includeDevDependencies ? '' : '--omit=dev'}`,
    { encoding: 'utf8' }
  ).toString("utf-8"))
} catch (error) {
  if (shouldLog) console.log(`\nError: ${error}\n`);
  if (error.status === 1) {
    npmAuditJson = JSON.parse(error.stdout.toString("utf-8"))
  } else {
    console.error(error);
    return;
  };
}

if (!npmAuditJson) {
  yargs.showHelp();
  return;
}

const metadata = npmAuditJson.metadata;
const vulnerabilities = npmAuditJson.vulnerabilities;

if (shouldLog) console.log('\n====== AUDIT DATA =====\n');
if (shouldLog) console.log(npmAuditJson);

if (metadata === undefined || vulnerabilities === undefined) {
  console.error('Invalid output from npm audit');
  return;
}

const data = Object.values(vulnerabilities)
  .filter((i) => 'critical' === i.severity.toLowerCase())
  .map((item) => ({
    package: item.name,
    range: item.range,
    descriptions: (item.via || [])
      .map((t) => t.title || '')
      .filter((e) => !!e)
      .filter((v, i, a) => a.indexOf(v) === i)
  }))
  .filter(({ descriptions }) => descriptions.length);

if (shouldLog) console.log('\n====== Vulnerabilities Data =====\n');
if (shouldLog) console.log(data);

const path = './.nvr'

let comments = {};
let refreshedComments = {};

if (shouldLog) console.log('\n====== Comments File =====\n');
try {
  if (fs.existsSync(path)) {
    if (shouldLog) console.log('File found');
    comments = JSON.parse(fs.readFileSync(path).toString("utf-8"))
  }
} catch (err) {
  if (shouldLog) console.error(err)
}

if (shouldLog) console.log('Data', comments);

const vulnerabilitiesTable = new Table({
  head: ['Package', 'Range', 'Vulnerability', 'Dep Tree', 'Comment', 'Risk'],
  colWidths: [20, 15, 45, 35, 45, 10],
  wordWrap: true,
  style: {
    head: [], //disable colors in header cells
    border: [],
  },
});

data.forEach(({ package, range, descriptions }) => {
  for (let i = 0; i < descriptions.length; i += 1) {
    const description = descriptions[i];
    const comment = comments[package] && comments[package][description]
      ? comments[package][description].comment || ''
      : '';
    const risk = comments[package] && comments[package][description]
      ? comments[package][description].risk || ''
      : '';
    if (refreshedComments[package]) {
      if (refreshedComments[package][description]) {
        refreshedComments[package][description].comment = comment || '';
        refreshedComments[package][description].risk = risk || '';
      } else {
        refreshedComments[package] = {
          ...refreshedComments[package],
          [description]: {
            comment: comment || '',
            risk: risk || '',
          },
        }
      }
    } else {
      refreshedComments[package] = {
        [description]: {
          comment: comment || '',
          risk: risk || '',
        },
      }
    }

    let depTree = 'unknow';
    try {
      depTree = execSync(
        `npm list ${package}`,
        { encoding: 'utf8'}
      ).replace(/.*/, "").substring(1);
    } catch (_e) {
      // nothing
    }

    vulnerabilitiesTable.push([
      package,
      range,
      descriptions[i],
      depTree,
      comment,
      risk,
    ]);
  }
});

if (shouldLog) console.log('\n====== Refreshed Comments File =====\n');
if (shouldLog) console.log('Data:', refreshedComments);

fs.writeFileSync(path, JSON.stringify(refreshedComments, null, 2) + '\n');

const package = JSON.parse(fs.readFileSync('./package.json').toString("utf-8"));
const nodeEngine = package.engines && package.engines.node
  ? `v${package.engines.node.split('.')[0].replace(/[^0-9]/, '')}`
  : undefined;
let nodeVersionHeaders = [];
let nodeVersionValues = [];
if (nodeEngine) {
  const releases = execSync(`curl -s https://raw.githubusercontent.com/nodejs/Release/main/schedule.json`).toString();
  const versions = JSON.parse(releases);
  const ltsDate = versions[nodeEngine].lts ? new Date(versions[nodeEngine].lts) : undefined;
  const maintenanceDate = new Date(versions[nodeEngine].maintenance);
  const endOfLifeDate = new Date(versions[nodeEngine].end);
  const today = new Date();
  const monthsToEOL = Math.ceil((endOfLifeDate - new Date()) / (1000 * 60 * 60 * 24 * 30));
  let status;
  if (today > endOfLifeDate) status = chalk.red('Not Supported');
  else if (today > maintenanceDate) status = chalk.green('Mantainence');
  else if (today > ltsDate) status = chalk.green('Active LTS');
  else status = chalk.yellow('Unstable');

  nodeVersionHeaders = ['-', 'Node Version', 'Status', 'Montsh Before EOL'];
  nodeVersionValues = [
    '-',
    nodeEngine,
    status,
    monthsToEOL,
  ];
}

const overviewTable = new Table({
  head: ['Dependencies', 'Critical', 'Critical %', ...nodeVersionHeaders],
  style: {
    head: [], //disable colors in header cells
    border: [],
  },
});
const total = includeDevDependencies ? metadata.dependencies.prod : metadata.dependencies.prod;
const critical = metadata.vulnerabilities.critical;

overviewTable.push([
  total,
  critical,
  Math.round((critical / total) * 1000) / 1000,
  ...nodeVersionValues,
]);

const output = '\n======================\n'
  + ` ${options.project || 'report'}`.toUpperCase()
  + '\n'
  + vulnerabilitiesTable.toString()
  + '\n'
  + overviewTable.toString()
  + '\n'

fs.writeFileSync(1, output);

