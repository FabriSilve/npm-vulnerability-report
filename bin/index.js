#! /usr/bin/env node
const fs = require('fs')
const chalk = require('chalk')
const boxen = require('boxen')
const yargs = require('yargs');
const Table = require('cli-table3');
const clear = require('clear');

clear();

const usage = chalk.keyword('violet')(
  "\nUsage: npm audit --omit=dev --json | nvr -p <project> \n"
  + boxen(
    chalk.green(
      "\n" + "Generate vulnerability report from a npm project\nbased on npm audit json reponse" + "\n"
    ),
    { padding: 1, borderColor: 'green', dimBorder: true },
  ) + "\n"
);

const options = yargs
  .usage(usage)
  .option("p", {
    alias: "project",
    describe: "Name of the analised project used in the report",
    type: "string",
    demandOption: false,
  })
  .option("r", {
    alias: "refresh-comments",
    describe: "Refresh comments file with vulnerabilities to populate",
    type: "boolean",
    demandOption: false,
  })
  .option("i", {
    alias: "ignore-comments",
    describe: "Ignore comments file in table population",
    type: "boolean",
    demandOption: false,
  })
  .option("d", {
    alias: "debug",
    describe: "Allow console log for debugging",
    type: "boolean",
    demandOption: false,
  })
  .help(true)
  .argv;

const npmAuditJson = JSON.parse(fs.readFileSync(0).toString("utf-8"));

if (!npmAuditJson) {
  yargs.showHelp();
  return;
}
const shouldLog = options.debug;
const refreshCommentFile = options.r;
if (shouldLog) console.log('\n====== LOG ENABLE =====\n');

const {
  metadata,
  vulnerabilities,
} = npmAuditJson;

if (shouldLog) console.log('\n====== AUDIT DATA =====\n');
if (shouldLog) console.log(npmAuditJson);

const data = Object.values(vulnerabilities)
  .filter((i) => 'critical' === i.severity.toLowerCase())
  .map((item) => ({
    package: item.name,
    range: item.range,
    descriptions: (item.via || [])
      .map((t) => t.title || '')
      .filter((e) => !!e)
      .filter((v, i, a) => a.indexOf(v) === i)
  }))
  .filter(({ descriptions }) => descriptions.length);

if (shouldLog) console.log('\n====== Vulnerabilities Data =====\n');
if (shouldLog) console.log(data);

const path = './.nvr'

let comments = {};
let refreshedComments = {};

if (shouldLog) console.log('\n====== Comments File =====\n');
if (shouldLog) console.log(`Ignore File: ${!!options.i}\n`);
try {
  if (!options.i && fs.existsSync(path)) {
    if (shouldLog) console.log('File found');
    comments = JSON.parse(fs.readFileSync(path).toString("utf-8"))
  }
} catch (err) {
  if (shouldLog) console.error(err)
}

if (shouldLog) console.log('Data', comments);

const vulnerabilitiesTable = new Table({
  head: ['Package', 'Range', 'Vulnerability', 'Comment'],
  colWidths: [20, 30, 50, 50],
  wordWrap: true,
});

data.forEach(({ package, range, descriptions }) => {
  for (let i = 0; i < descriptions.length; i += 1) {
    const comment = comments[package]
      ? comments[package][descriptions[i]] || ''
      : '';
    if (refreshCommentFile) {
      if (refreshedComments[package]) {
        refreshedComments[package][descriptions[i]] = comment || '';
      } else {
        refreshedComments[package] = {
          [descriptions[i]]: ''
        }
      }
    }
    vulnerabilitiesTable.push([
      package,
      range,
      descriptions[i],
      comment,
    ]);
  }
});

if (shouldLog) console.log('\n====== Refreshed Comments File =====\n');
if (shouldLog) console.log('Data:', refreshedComments);

if (refreshCommentFile) {
  fs.writeFileSync(path, JSON.stringify(refreshedComments, null, 2));
}

const overviewTable = new Table({ head: ['Dependencies', 'Critical', 'Critical %'] });
overviewTable.push([
  metadata.dependencies.prod,
  metadata.vulnerabilities.critical,
  metadata.vulnerabilities.info / metadata.dependencies.total
]);

const output = '\n'
  + chalk.green(` ${options.project || 'report'}`.toUpperCase())
  + '\n'
  + vulnerabilitiesTable.toString()
  + '\n'
  + overviewTable.toString()
  + '\n'

fs.writeFileSync(1, output);
